package gov.usgswim.sparrow.service.predict.filter;

import gov.usgs.cida.datatable.DataTable;
import gov.usgs.cida.datatable.filter.RowFilter;
import gov.usgswim.sparrow.action.LoadReachesInBBox;
import gov.usgswim.sparrow.domain.ModelBBox;
import gov.usgswim.sparrow.service.SharedApplication;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;

import org.apache.commons.lang.StringUtils;

/**
 * A predicate class for determining whether or not a row should be output by
 * the predict export service.  This filter is applied when the user has chosen
 * to limit their export to the reaches within the viewport, but has not
 * aggregated the results in any way.
 */
public class PredictExportFilter implements RowFilter {

	private Connection conn;
	private Long[] results = null;
	Long modelId;
	String bbox;

	public PredictExportFilter(Long modelId, String bbox) throws Exception {
		this.modelId = modelId;
		this.bbox = bbox;
		results = getResults(modelId, bbox);
	}

	/**
	 * Determines whether or not to accept the given row from the given table
	 * by checking for the existence of the row's id in the result set.  To
	 * elaborate, a set of reach ids is generated by querying for the set of
	 * geometries that exist within a specified bounding box.  If the row id
	 * for {@code rowNum} is contained within that result set, the row is
	 * accepted and is not filtered.
	 *
	 * Note that this algorithm assumes that the result set and datatable
	 * source are sorted identically.  Further, the reaches contained within the
	 * result set must be a subset (proper or not) of the reaches within the
	 * source datatable.
	 */
	public boolean accept(DataTable tableWithRowIDs, int rowNum) {
		Long identifier = tableWithRowIDs.getIdForRow(rowNum);
		return (Arrays.binarySearch(results, identifier) > -1);
	}
	
	public Integer getEstimatedAcceptCount() {
		if (results != null) {
			return results.length;
		} else {
			return null;
		}
	}


	/**
	 * Returns a sorted list of identifiers for reaches that fall within the bounding
	 * box defined by the specified arguments. A reach is considered to fall
	 * within the bounding box if any part of its geometry falls within the
	 * bounding box.
	 *
	 * @return A list of identifiers for reaches that fall within the defined
	 *         bounding box.
	 * @throws Exception 
	 */
	private Long[] getResults(Long modelId, String bounds) throws Exception {
		ModelBBox modelBBox = new ModelBBox(modelId, bounds);
		Long[] ids = SharedApplication.getInstance().getReachesInBBox(modelBBox);
		return ids;
	}
}
